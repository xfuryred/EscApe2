/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MarkdownBlogger
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var fs = __toESM(require("fs"));
var path = __toESM(require("path"));
var os = __toESM(require("os"));
var DEFAULT_SETTINGS = {
  projectFolder: "",
  showHiddenFolders: false
};
var MarkdownBlogger = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "validate-path",
      name: "Validate path",
      editorCallback: (editor, view) => {
        const { projectFolder } = this.settings;
        if (!fs.existsSync(projectFolder)) {
          new ErrorModal(this.app).open();
          return;
        }
        new import_obsidian.Notice(`Valid path: ${this.settings.projectFolder}`);
      }
    });
    this.addCommand({
      id: "push-md",
      name: "Push markdown",
      editorCallback: (editor, view) => {
        const { projectFolder } = this.settings;
        if (!fs.existsSync(projectFolder)) {
          new ErrorModal(this.app).open();
          return;
        }
        const text = editor.getDoc().getValue();
        const projectBlogPath = path.resolve(this.settings.projectFolder, view.file.name);
        try {
          fs.writeFileSync(`${projectBlogPath}`, text, { encoding: "utf8" });
          new import_obsidian.Notice(`Your file has been pushed! At ${projectBlogPath}`);
        } catch (err) {
          new import_obsidian.Notice(err.message);
        }
      }
    });
    this.addCommand({
      id: "pull-md",
      name: "Pull markdown",
      editorCheckCallback: (checking, editor, view) => {
        const projectBlogPath = path.resolve(this.settings.projectFolder, view.file.name);
        if (fs.existsSync(projectBlogPath)) {
          if (!checking) {
            try {
              const file = fs.readFileSync(projectBlogPath, "utf8");
              editor.getDoc().setValue(file);
              new import_obsidian.Notice(`Your file has been pulled! From ${projectBlogPath}`);
            } catch (err) {
              new import_obsidian.Notice(err.message);
            }
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "push-custom-path-md",
      name: "Push to custom path",
      editorCallback: (editor, view) => {
        new PathModal(this.app, this.settings, 0 /* Push */).open();
      }
    });
    this.addCommand({
      id: "pull-custom-path",
      name: "Pull from custom path",
      editorCallback: (editor, view) => {
        new PathModal(this.app, this.settings, 1 /* Pull */).open();
      }
    });
    this.addSettingTab(new MarkdownBloggerSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var ErrorModal = class extends import_obsidian.Modal {
  constructor(app) {
    super(app);
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.setText("The project folder does not exist. Please create the path or update the current path in plugin settings.");
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var PathModal = class extends import_obsidian.FuzzySuggestModal {
  constructor(app, settings, action) {
    super(app);
    this.currPath = os.homedir();
    this.settings = settings;
    this.action = action;
  }
  getItems() {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    const paths = fs.readdirSync(this.currPath).filter((p) => {
      const fullPath = path.resolve(this.currPath, p);
      let stats;
      try {
        stats = fs.statSync(fullPath, { throwIfNoEntry: false });
      } catch (e) {
        return false;
      }
      if (stats === void 0)
        return false;
      return (stats.isDirectory() || path.basename(fullPath) === (view == null ? void 0 : view.file.name)) && (p[0] !== "." || this.settings.showHiddenFolders);
    });
    paths.push("..");
    paths.push("Select");
    return paths;
  }
  getItemText(dir) {
    return dir;
  }
  onChooseItem(dir, evt) {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (dir === "Select") {
      if (view) {
        if (!fs.existsSync(path.resolve(this.currPath))) {
          new ErrorModal(this.app).open();
          return;
        }
        const text = view.editor.getDoc().getValue();
        const filePath = path.resolve(this.currPath, view.file.name);
        if (this.action === 0 /* Push */) {
          try {
            fs.writeFileSync(`${filePath}`, text, { encoding: "utf8" });
            new import_obsidian.Notice(`Your file has been pushed! At ${filePath}`);
          } catch (err) {
            new import_obsidian.Notice(err.message);
          }
        } else if (this.action === 1 /* Pull */) {
          try {
            const file = fs.readFileSync(filePath, "utf8");
            view.editor.getDoc().setValue(file);
            new import_obsidian.Notice(`Your file has been pulled! From ${filePath}`);
          } catch (err) {
            new import_obsidian.Notice(err.message);
          }
        }
      }
      return;
    } else if (view && dir === view.file.name) {
      const filePath = path.resolve(this.currPath, view.file.name);
      if (this.action === 0 /* Push */) {
        const text = view.editor.getDoc().getValue();
        try {
          fs.writeFileSync(`${filePath}`, text, { encoding: "utf8" });
          new import_obsidian.Notice(`Your file has been pushed! At ${filePath}`);
        } catch (err) {
          new import_obsidian.Notice(err.message);
        }
      } else if (this.action === 1 /* Pull */) {
        try {
          const file = fs.readFileSync(filePath, "utf8");
          view.editor.getDoc().setValue(file);
          new import_obsidian.Notice(`Your file has been pulled! From ${filePath}`);
        } catch (err) {
          new import_obsidian.Notice(err.message);
        }
      }
      return;
    } else {
      this.currPath = path.normalize(path.join(this.currPath, dir));
    }
    this.open();
  }
};
var MarkdownBloggerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for Obsidian Markdown Blogger." });
    new import_obsidian.Setting(containerEl).setName("Local project folder path").setDesc("The local project folder for your blog, portfolio, or static site. Must be an absolute path.").addText(
      (text) => text.setPlaceholder("/Users/johnsample/projects/astro-blog/collections/").setValue(this.plugin.settings.projectFolder).onChange(async (value) => {
        this.plugin.settings.projectFolder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show hidden folders").setDesc("Show hidden folders when pushing to a custom path").addToggle(
      (cb) => cb.setValue(this.plugin.settings.showHiddenFolders).onChange(async (value) => {
        this.plugin.settings.showHiddenFolders = value;
        await this.plugin.saveSettings();
      })
    );
  }
};


/* nosourcemap */